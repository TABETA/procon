{
  "treap": {
    "prefix": "treap",
    "body": [
      "class Treap {",
      "  private:",
      "    struct Node {",
      "        int val, size, priority;",
      "        Node *left, *right;",
      "        Node(int v)",
      "            : val(v),",
      "              size(1),",
      "              priority(rand()),",
      "              left(nullptr),",
      "              right(nullptr) {}",
      "    };",
      "",
      "    Node* root;",
      "",
      "    int getSize(Node* t) { return t ? t->size : 0; }",
      "",
      "    void update(Node* t) {",
      "        if (t) t->size = 1 + getSize(t->left) + getSize(t->right);",
      "    }",
      "",
      "    void split(Node* t, int k, Node*& l, Node*& r) {",
      "        if (!t) {",
      "            l = r = nullptr;",
      "        } else if (getSize(t->left) >= k) {",
      "            split(t->left, k, l, t->left);",
      "            r = t;",
      "            update(r);",
      "        } else {",
      "            split(t->right, k - getSize(t->left) - 1, t->right, r);",
      "            l = t;",
      "            update(l);",
      "        }",
      "    }",
      "",
      "    Node* merge(Node* l, Node* r) {",
      "        if (!l || !r) return l ? l : r;",
      "        if (l->priority > r->priority) {",
      "            l->right = merge(l->right, r);",
      "            update(l);",
      "            return l;",
      "        } else {",
      "            r->left = merge(l, r->left);",
      "            update(r);",
      "            return r;",
      "        }",
      "    }",
      "",
      "    void insert(Node*& t, int pos, int val) {",
      "        Node *l, *r;",
      "        split(t, pos, l, r);",
      "        Node* newNode = new Node(val);",
      "        t = merge(merge(l, newNode), r);",
      "    }",
      "",
      "    void erase(Node*& t, int pos) {",
      "        Node *l, *r, *m;",
      "        split(t, pos, l, r);",
      "        split(r, 1, m, r);",
      "        delete m;",
      "        t = merge(l, r);",
      "    }",
      "",
      "    int get(Node* t, int pos) {",
      "        if (!t) throw out_of_range(\"Index out of range\");",
      "        int leftSize = getSize(t->left);",
      "        if (pos < leftSize)",
      "            return get(t->left, pos);",
      "        else if (pos == leftSize)",
      "            return t->val;",
      "        else",
      "            return get(t->right, pos - leftSize - 1);",
      "    }",
      "",
      "    void print(Node* t) {",
      "        if (!t) return;",
      "        print(t->left);",
      "        cout << t->val << \" \";",
      "        print(t->right);",
      "    }",
      "",
      "    void clear(Node* t) {",
      "        if (!t) return;",
      "        clear(t->left);",
      "        clear(t->right);",
      "        delete t;",
      "    }",
      "",
      "  public:",
      "    Treap() : root(nullptr) {",
      "        srand(time(nullptr));  // 乱数初期化（必要に応じて一度だけ）",
      "    }",
      "",
      "    ~Treap() { clear(root); }",
      "",
      "    void insert(int pos, int val) { insert(root, pos, val); }",
      "",
      "    void erase(int pos) { erase(root, pos); }",
      "",
      "    int get(int pos) { return get(root, pos); }",
      "",
      "    void print() {",
      "        print(root);",
      "        cout << endl;",
      "    }",
      "",
      "    int size() { return getSize(root); }",
      "};",
    ],
    "description": "Treap"
  },
  "getTermminalNode": {
    "prefix": "getTermminalNode",
    "body": [
      "auto getTerminalNode = [&](ll start){",
      "    auto bfs = [&](ll start){",
      "        vll distance(N, linf);",
      "        distance[start] = 0;",
      "        queue<ll> q;",
      "        q.emplace(start);",
      "        vector used(N, false);",
      "        while(!q.empty()){",
      "            auto u = q.front(); q.pop();",
      "            for (auto &&v : to[u]){",
      "                if(used[v])continue;",
      "                used[v] = true;",
      "                distance[v] = distance[u] + 1;",
      "                q.emplace(v);",
      "            }",
      "        }",
      "        return distance;",
      "    };",
      "    auto d1 = bfs(start);",
      "    ll u = max_element(all(d1)) - d1.begin();",
      "    auto d2 = bfs(u);",
      "    ll v = max_element(all(d2)) - d2.begin();",
      "    return v;",
      "};",
    ],
    "description": "木の端点を求めます"
  },
  "manacher": {
    "prefix": "manacher",
    "body": [
      "vector<ll> manacher(const string& s) {",
      "    ll N = s.size();",
      "    vector<ll> r(N);",
      "    ll i = 0, j = 0;",
      "    while (i < N) {",
      "        while (i-j >= 0 && i+j < N && s[i-j] == s[i+j]) ++j;",
      "        r[i] = j;",
      "        ll k = 1;",
      "        while (i-k >= 0 && i+k < N && k+r[i-k] < j) r[i+k] = r[i-k], ++k;",
      "        i += k; j -= k;",
      "    }",
      "    return r;",
      "}"
    ],
    "description": "マナチャー法"
  },
  "rotate90": {
    "prefix": "rotate90",
    "body": [
      "template<typename T>",
      "vector<vector<T>> rotate90(const vector<vector<T>>& arr) {",
      "    int N = arr.size();",
      "    vector<vector<T>> rotated(N, vector<T>(N));",
      "    for (int i = 0; i < N; ++i) {",
      "        for (int j = 0; j < N; ++j) {",
      "            rotated[j][N - 1 - i] = arr[i][j];",
      "        }",
      "    }",
      "    return rotated;",
      "}"
    ],
    "description": "90度回転"
  },
  "grouping": {
    "prefix": "grouping",
    "body": [
      "auto dfs = [&](auto dfs, ll i) -> void{",
      "  if(i == N){",
      "      /* to implement here */",
      "      return;",
      "  }",
      "  rep(j,G.size()){",
      "      G[j].emplace_back(i);",
      "      dfs(dfs, i + 1);",
      "      G[j].pop_back();",
      "  }",
      "  G.emplace_back(vll{i});",
      "  dfs(dfs, i + 1);",
      "  G.pop_back();",
      "};",
      "dfs(dfs, 0);"
    ],
    "description": "グループ分け"
  },
  "rand_between": {
    "prefix": "rand_between",
    "body": [
      "auto rand_between = [](ll min, ll max) -> ll {",
      "    return min + rand() % (max - min);",
      "};",
    ],
    "description": "乱数生成"
  },
  "fast_combination": {
    "prefix": "fast_combination",
    "body": [
      "struct modinv {",
      "  int n; vector<mint> d;",
      "  modinv(): n(2), d({0,1}) {}",
      "  mint operator()(int i) {",
      "    while (n <= i) d.push_back(-d[mint::mod()%n]*(mint::mod()/n)), ++n;",
      "    return d[i];",
      "  }",
      "  mint operator[](int i) const { return d[i];}",
      "} invs;",
      "struct modfact {",
      "  int n; vector<mint> d;",
      "  modfact(): n(2), d({1,1}) {}",
      "  mint operator()(int i) {",
      "    while (n <= i) d.push_back(d.back()*n), ++n;",
      "    return d[i];",
      "  }",
      "  mint operator[](int i) const { return d[i];}",
      "} facts;",
      "struct modfactinv {",
      "  int n; vector<mint> d;",
      "  modfactinv(): n(2), d({1,1}) {}",
      "  mint operator()(int i) {",
      "    while (n <= i) d.push_back(d.back()*invs(n)), ++n;",
      "    return d[i];",
      "  }",
      "  mint operator[](int i) const { return d[i];}",
      "} ifacts;",
      "mint comb(int n, int k) {",
      "  if (n < k || k < 0) return 0;",
      "  return facts(n)*ifacts(k)*ifacts(n-k);",
      "}"
    ],
    "description": "高速に組み合わせの数を求めます(MOD値)"
  },
  "get_loop_count": {
    "prefix": "get_cycle_count",
    "body": [
      "vector used(N, 0);",
      "auto dfs = [&](auto dfs, ll pre, ll u) -> ll{",
      "    used[u] = 1;",
      "    ll ans = 0;",
      "    repr(v,to[u]){",
      "        if(v == pre) continue;",
      "        if(used[v] == 2)continue;",
      "        if(used[v] == 1){",
      "            ++ans;",
      "            continue;",
      "        }",
      "        ans += dfs(dfs, u, v);",
      "    }",
      "    used[u] = 2;",
      "    return ans;",
      "};",
    ],
    "description": "サイクルの数をカウントします"
  },
  "binary_search": {
    "prefix": "binary_search",
    "body": [
      "auto f = [&](ll wj){",
      "};",
      "auto binary_search = [&](auto f, ll ac, ll wa) -> ll {",
      "    while (abs(ac - wa) > 1) {",
      "        ll wj = (ac + wa) / 2;",
      "        if (f(wj))",
      "            ac = wj;",
      "        else",
      "            wa = wj;",
      "    }",
      "    return ac;",
      "};",
    ],
    "description": "二分探索"
  },
  "AtCoderLibrary": {
    "prefix": "acl",
    "body": [
      "#include <atcoder/all>",
      "using namespace atcoder;"
    ],
    "description": "AtCoder Libraryをincludeします"
  },
  "ペア型入力": {
    "prefix": "input_pll",
    "body": [
      "using P = pair<ll,ll>;",
      "vector<P> ${1:A}(${2:N});",
      "for(auto& [y, x]: ${1:A}){",
      "    cin >> y;",
      "    cin >> x;",
      "}",
    ],
    "description": "ペア型の入力を受け取ります"
  },
  "隣接リスト入力": {
    "prefix": "input_adjacent_list",
    "body": [
      "vvll to(N);",
      "rep(_,M){",
      "    CIN(ll,u);--u;",
      "    CIN(ll,v);--v;",
      "    to[u].emplace_back(v);",
      "    to[v].emplace_back(u);",
      "}",
    ],
    "description": "隣接リストの入力を受け取ります"
  },
  "ワーシャルフロイド": {
    "prefix": "warshall_floyd",
    "body": [
      "vector G(N,vector(N, linf))",
      "rep(k,N)rep(i,N)rep(j,N) chmin(G[i][j], G[i][k] + G[k][j]);",
    ],
    "description": "ワーシャルフロイド法で最小全域木を求めます。"
  },
  "隣接グリッド取得": {
    "prefix": "next_adjacents",
    "body": [
      "auto next_adjacents(P p, ll H, ll W) {",
      "  auto [r, c] = p;",
      "  vector<P> ret;",
      "  for (auto &&q : {",
      "      P{r - 1, c},",
      "      P{r + 1, c},",
      "      P{r, c - 1},",
      "      P{r, c + 1},",
      "  })",
      "  {",
      "      auto [y,x] = q;",
      "      if (y < 0 || y >= H || x < 0 || x >= W) continue;",
      "      ret.push_back(q);",
      "  }",
      "  return ret;",
      "};",
    ],
    "description": "二次元配列における隣接セルのインデックスを返します"
  },
  "foritr": {
    "prefix": "foritr",
    "body": [
      "for(auto ${1:it} = ${2:A}.begin(); ${1:it} != ${2:A}.end(); ++${1:it}){",
      "}",
    ],
    "description": "iteratorでのforループ"
  },
  "combination": {
    "prefix": "combination",
    "body": [
      "auto nCr(ll n, ll r)->ll{",
      "  ll denominator = 1;",
      "  ll numerator = 1;",
      "  while(r){",
      "      denominator *= n--;",
      "      numerator *= r--;",
      "      ll g = gcd(denominator, numerator);",
      "      denominator /= g;",
      "      numerator /= g;",
      "  }",
      "  return denominator/numerator;",
      "}"
    ],
    "description": "組み合わせの数"
  },
  "幅優先探索": {
    "prefix": "bfs",
    "body": [
      "queue<${1:type}> Q;",
      "Q.emplace(${2:initialValue});",
      "vector used(N, false);",
      "while(!Q.empty()){",
      "    auto u = Q.front();Q.pop();",
      "    for(auto&& v: to[u]){",
      "        if(used[v])continue;",
      "        used[v] = true;",
      "        Q.emplace(v);",
      "    }",
      "}"
    ],
    "description": "幅優先探索"
  },
  "深さ優先探索": {
    "prefix": "dfs",
    "body": [
      "auto dfs = [&](auto dfs, ll u) -> void{",
      "    for(auto&& v: to[u]){",
      "        dfs(dfs, v);",
      "    }",
      "};",
      "dfs(dfs, 0);",
    ],
    "description": "深さ優先探索"
  },
  "legendre": {
    "prefix": "legendre",
    "body": [
      "auto legendre(ll N, ll p)->ll{",
      "    if(N < p){",
      "        return 0;",
      "    }",
      "    ll res = N/p;",
      "    return res + legendre(res, p);",
      "}"
    ],
    "description": "N!を素数pで割り切れる回数を返します"
  },
  "pll": {
    "prefix": "pll",
    "body": "using P = pair<ll,ll>;",
    "description": "pair of long long"
  },
  "Dijkstra": {
    "prefix": "dijkstra",
    "body": [
      "struct Edge{",
      "    ll distance;",
      "    ll to;",
      "};",
      "using Edges = vector<Edge>;",
      "using Nodes = vector<Edges>;",
      "using P = pair<ll,ll>;",
      "",
      "auto dijkstra(Nodes G, ll start){",
      "    vll distance(G.size(), numeric_limits<ll>::max());",
      "    distance[start] = 0;",
      "    priority_queue<P, vector<P>, greater<P>> q;",
      "    q.emplace(0,start);",
      "    while(!q.empty()){",
      "        auto [t, from] = q.top(); q.pop();",
      "        if(distance[from] < t) continue;",
      "        for (auto &&e : G[from])",
      "        {",
      "            auto j = e.to;",
      "            auto newDistance = distance[from] + e.distance;",
      "            if(distance[j] > newDistance){",
      "                distance[j] = newDistance;",
      "                q.emplace(newDistance, j);",
      "            }",
      "        }",
      "    }",
      "    return distance;",
      "}",
    ],
    "description": "dijkstra"
  },
  "EnumeratePrimeNumbers": {
    "prefix": "enumpn",
    "body": [
      "vector<ll> enumeratePrimeNumbers(const ll N) {",
      "  vector<bool> is_prime(N + 1, true);",
      "  vector<ll> P;",
      "  for (ll i = 2; i <= N; i++) {",
      "      if (is_prime[i]) {",
      "          for (ll j = 2 * i; j <= N; j += i) {",
      "              is_prime[j] = false;",
      "          }",
      "          P.emplace_back(i);",
      "      }",
      "  }",
      "  return P;",
      "}",
    ],
    "description": "enumerate prime numbers"
  },
  "EnumerateDivisor": {
    "prefix": "enumdiv",
    "body": [
      "template<typename T>",
      "vector<T> divisor(T n) {",
      "    vector<T> ret;",
      "    for (T i = 1; i * i <= n; i++) {",
      "        if (n % i == 0) {",
      "            ret.push_back(i);",
      "            if (i * i != n) ret.push_back(n / i);",
      "        }",
      "    }",
      "    sort(ret.begin(), ret.end());",
      "    return ret;",
      "}"
    ],
    "description": "enumerate divisor"
  },
  "UnionFind": {
    "prefix": "uf",
    "body": [
      "template<typename T>",
      "class UnionFind",
      "{",
      "public:",
      "",
      "  UnionFind() = default;",
      "",
      "  /// @brief Union-Find 木を構築します。",
      "  /// @param n 要素数",
      "  explicit UnionFind(size_t n)",
      "    : m_parentsOrSize(n, -1) {}",
      "",
      "  /// @brief 頂点 i の root のインデックスを返します。",
      "  /// @param i 調べる頂点のインデックス",
      "  /// @return 頂点 i の root のインデックス",
      "  T find(T i)",
      "  {",
      "    if (m_parentsOrSize[i] < 0)",
      "    {",
      "      return i;",
      "    }",
      "",
      "    // 経路圧縮",
      "    return (m_parentsOrSize[i] = find(m_parentsOrSize[i]));",
      "  }",
      "",
      "  /// @brief a のグループと b のグループを統合します。",
      "  /// @param a 一方のインデックス",
      "  /// @param b 他方のインデックス",
      "  void merge(T a, T b)",
      "  {",
      "    a = find(a);",
      "    b = find(b);",
      "",
      "    if (a != b)",
      "    {",
      "      // union by size (小さいほうが子になる）",
      "      if (-m_parentsOrSize[a] < -m_parentsOrSize[b])",
      "      {",
      "        std::swap(a, b);",
      "      }",
      "",
      "      m_parentsOrSize[a] += m_parentsOrSize[b];",
      "      m_parentsOrSize[b] = a;",
      "    }",
      "  }",
      "",
      "  /// @brief a と b が同じグループに属すかを返します。",
      "  /// @param a 一方のインデックス",
      "  /// @param b 他方のインデックス",
      "  /// @return a と b が同じグループに属す場合 true, それ以外の場合は false",
      "  bool isSame(T a, T b)",
      "  {",
      "    return (find(a) == find(b));",
      "  }",
      "",
      "  /// @brief i が属するグループの要素数を返します。",
      "  /// @param i インデックス",
      "  /// @return i が属するグループの要素数",
      "  T size(T i)",
      "  {",
      "    return -m_parentsOrSize[find(i)];",
      "  }",
      "",
      "private:",
      "",
      "  // m_parentsOrSize[i] は i の 親,",
      "  // ただし root の場合は (-1 * そのグループに属する要素数)",
      "  std::vector<T> m_parentsOrSize;",
      "};",
    ],
    "description": "UnionFind"
  },
  "average": {
    "prefix": "avg",
    "body": [
      "template<typename T> inline T average(std::vector<T> const& v){",
      "  if(v.empty()){",
      "      return 0;",
      "  }",
      "  auto const count = static_cast<T>(v.size());",
      "  return std::reduce(all(v)) / count;",
      "}",
    ],
    "description": "average"
  },
  "join": {
    "prefix": "join",
    "body": [
      "template <typename T>",
      "std::string join(const std::vector<T> &v, const char *delim = nullptr)",
      "{",
      "    auto to_str = [](T val) -> string {",
      "        if constexpr (is_same<T, string>::value)",
      "            return val;",
      "        else",
      "            return to_string(val);",
      "    };",
      "    std::string s;",
      "    if (!v.empty())",
      "    {",
      "        s += to_str(v[0]);",
      "",
      "        for (size_t i = 1, c = v.size(); i < c; ++i)",
      "        {",
      "            if (delim)",
      "                s += delim;",
      "            s += to_str(v[i]);",
      "        }",
      "    }",
      "    return s;",
      "}",
    ],
    "description": "join"
  },
  "素因数分解": {
    "prefix": "prime_factorize",
    "body": [
      "template <typename T>",
      "vector<pair<T, T> > prime_factorize(T N) {",
      "    vector<pair<T, T> > res;",
      "    for (T a = 2; a * a <= N; ++a) {",
      "        if (N % a != 0) continue;",
      "        T ex = 0;",
      "        while (N % a == 0) {",
      "            ++ex;",
      "            N /= a;",
      "        }",
      "        res.push_back({a, ex});",
      "    }",
      "    if (N != 1) res.push_back({N, 1});",
      "    return res;",
      "}"
    ],
    "description": "Returns the result of prime factorization"
  }
}